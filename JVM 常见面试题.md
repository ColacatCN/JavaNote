# JVM 常见面试题

## 类加载过程

类加载是一个将 .class 字节码文件实例化成 Class 对象并进行相关初始化的过程。主要有三步：加载 ---> 链接 ---> 初始化，其中链接这一步又可以分为：验证 ---> 准备 ---> 解析。

### 加载

作为类加载过程的第一步，主要完成如下三件事情：

1. 根据指定的全限定类名获取 .class 字节码文件的二进制字节流；

2. 将字节流所代表的静态数据结构转换为方法区的运行时数据结构；

3. 在堆内存中生成一个代表该类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

### 链接

1. 验证：需要核验 .class 字节码文件的二进制字节流是符合 JVM 的规范；

2. 准备：为类中的静态字段分配内存并设置默认的初始值。需要注意的是，被 final 关键字修饰的静态字段在编译期就已经为其分配了内存。

3. 解析：将常量池中的符号引用替换为直接引用（ 内存地址 ）。

### 初始化

初始化是类加载的最后一步，是执行 clinit() 类构造方法的过程，其作用是去初始化**静态变量**和**静态代码块**。若该类具有父类，JVM 会保证父类的 clinit() 方法先被执行，然后再执行子类的 clinit() 方法。

## 类加载器

类加载器的作用就是根据指定的全限定类名将 .class 字节码文件加载到 JVM 中并实例化成对应的 Class 对象。

* 启动类加载器（ Bootstrap ClassLoader ）：最顶层的加载器，由 C++ 实现，负责加载 Java 的核心类库，例如：%JRE_HOME%\lib\rt.jar、%JRE_HOME%\lib\resources.jar、sun.boot.class.path 路径下的 jar 包。

* 扩展类加载器（ Extension ClassLoader ）：负责加载 %JAVA_HOME%\lib\ext 目录下的 jar 包以及被系统变量 java.ext.dirs 所指定路径下的 jar 包。
 
* 应用程序类加载器（ Application ClassLoader ）：负责加载用户类路径 classpath 目录下的所有 jar 包。

### 什么是双亲委派模式？

每一个类都有一个对应它的类加载器。如果一个类加载器接收到了类加载的请求，它自己不会先去加载，而是把这个请求委托给父类加载器去执行。如果父类还存在父类加载器，则继续向上委托，一直委托到启动类加载器 `Bootstrap ClassLoader`。如果父类加载器在自己的搜索范围内可以完成加载任务，就返回成功结果；如果父类加载器加载失败，就由子类加载器自己去尝试加载，如果子类加载器同样加载失败就会抛出 `ClassNotFoundException` 异常。

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        Class<?> c = findLoadedClass(name); // 首先检查请求加载的类是否已经被加载过
        if (c == null) { // 如果该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) { // 如果父类加载器不为 null，则调用其 loadClass() 方法尝试加载（ 递归 ）
                    c = parent.loadClass(name, false);
                } else { // 如果父类加载器为 null，说明溯源到了最顶层，使用启动类加载器 BootstrapClassLoader 尝试加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) { 
                // 抛出异常，说明父类加载器无法完成加载请求
            }

            if (c == null) {
                long t1 = System.nanoTime();
                c = findClass(name); // 既然上面两位大佬都没加载成功，那么只能靠应用程序类加载器 Application ClassLoader 自己去加载了

                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

### 为什么需要双亲委派模式？

JVM 区分不同类的方式不仅仅根据全限定的类名，如果相同的 .class 字节码文件被不同的类加载器加载后会产生两个不同的 Class 对象。双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，同时也保证了 Java 核心的 API 不被篡改。

如果没有使用双亲委派模型，而是放任每个类加载器去加载自己内容的话就会出现一些问题，比如编写一个名为 java.lang.Object 的类，那么程序执行的时候系统中就会出现多个不同的 Object 类。

### 如何打破双亲委派模式？

首先需要继承父类 ClassLoader，并覆写其成员方法 loadClass()；而自定义类加载器需要覆写的是 loadClass() 方法内部的 findClass() 方法。

## JVM 内存模型（ 内存布局 ）

1. 程序计数器：是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

   * 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   
   * 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

2. 本地方法栈：虚拟机栈为虚拟机执行 Java 方法（ 也就是字节码 ）；而本地方法栈则为虚拟机执行 Native 方法。

3. 虚拟机栈

4. 堆

## 什么情况下会发生栈内存溢出？

* 虚拟机栈是线程私有的，它的生命周期与线程相同，每个方法在执行时都会在栈顶创建一个栈帧，用来存储局部变量表（ 方法参数和局部变量 ）、操作栈（ 在方法执行的过程中，会有各种字节码指令往操作栈中写入和提取内容，也就是出、入栈操作）、动态链接和方法返回地址（ 返回到方法被调用的位置 ）等信息。

* 如果线程请求的栈深度大于虚拟机所允许的最大深度，那么将抛出 StackOverflowError 异常（ 方法的递归调用容易产生这种结果 ）。

* 如果虚拟机栈支持动态扩展，并且扩展的动作已经尝试过了，但仍然无法申请到足够的内存去完成扩展，或者在创建线程时没有足够的内存去创建对应的虚拟机栈，那么将抛出一个 OutOfMemoryError 异常（ 线程启动过多 ）。

* 参数 -Xss 调整虚拟机栈的大小。

## 堆内存为什么要分成新生代和老年代？新生代中为什么要分为 Eden 和 Survivor？

**1. 共享内存区**

   * 共享内存区 = 堆 + 元数据区

   * 堆 = 新生代 + 老年代

   * 新生代 = Eden + S0 + S1

   * 元数据区 = 运行时常量池 + klass 类元信息 + 其他
  
**2. 基本配置参数**

   * 新生代与老年代的比例默认为 1:2，可以通过参数 -XX:NewRatio 配置
  
   * Eden、S0 和 S1 的比例默认为 8:1:1，可以通过参数 –XX:SurvivorRatio 配置
  
   * 对象在 Survivor 区内最多被复制 15 次后将被晋升至老年代，可以通过参数 -XX:MaxTenuringThreshold 配置

**3. 为什么要分成新生代和老年代？**

因为有的对象寿命长，有的对象寿命短。应该将寿命短的对象单独存放在一个区，满足一定的条件后再将其移动至另外一个专门存放寿命较长的对象的区。这样方便在不同的区内采用不同的垃圾收集算法，寿命短的区清理频次高一点，寿命长的区清理频次低一点，能够提高 GC 的效率。

**4. 新生代中为什么要分为 Eden 和 Survivor？**

   * Survivor 区存在的意义就是减少被送到老年代对象的数量，进而减少发生 Full GC 的次数。Survivor 区的预筛选保证了只有经历 15 次 Young GC 还能在新生代中存活的对象，才会被送到老年代。如果没有 Survivor 区，Eden 区每进行一次 Young GC，存活的对象就会被送到老年代，这样老年代很快就会被填满从而触发 Full GC。由于老年代的内存空间要远大于新生代，进行一次 Full GC 消耗的时间也要比 Young GC 长得多，所以需要分为 Eden 区和 Survivor 区。
  
   * 设置两个 Survivor 区最大的好处就是解决了碎片化问题。刚刚创建出的对象会先被存放在 Eden 区中，当经历一次 Young GC 后，Eden 区中的存活对象就会被移动到 S0 并清空 Eden 区。等 Eden 区再满了，就再触发一次 Young GC，此时会将 Eden 区和 S0 中的存活对象一并复制送入 S1。这个过程非常重要，因为这种复制算法保证了 S1 中来自 Eden 区和 S0 两部分的存活对象占用了连续的内存空间，从而避免了碎片化的发生。
   
## JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代？

当 Eden 区的空间被填满时，JVM 就会触发一次 Young GC，目标是收集新生代的垃圾。存活下来的对象则会被转移到 Survivor 区，它们每经历一次 Young GC，年龄都会加 1，如果年龄达到 15 时就会被晋升为老年代。如果遇到超大型（ 需要大量连续内存空间 ）的对象，同样先触发一次 Young GC，存不下的话再进入老年代，如果连老年代都存不下的话抛出 OutOfMemoryError 异常（ 这中间会有一次 Full GC ）。

当 Old 区的空间被填满时，JVM 就会触发一次 Full GC，目标是收集整个堆内存中的垃圾，通常要比 Young GC 慢 10 倍以上。

## 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 CMS 和 G1 包括原理、流程、优缺点。

引用计数算法（ 废弃 ）：每个对象内部都维护着一个引用计数器，当有一个新的引用指向该对象时，引用计数器就加 1，当指向该对象的引用失效时，就将引用计数器减 1。当引用计数器的值为 0 时，则说明该对象没有被任何引用指向，可以被清理。

可达性分析算法：以 GC-Roots 为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象和 GC-Roots 之间没有任何一条引用链相连时，则证明此对象是不可用的。

可以作 GC-Roots 的对象包含：方法区中类静态变量引用的对象、方法区中常量引用的对象、虚拟机栈中（ 栈帧中的局部变量表 ）引用的对象、本地方法栈中引用的对象。

   * Serial 收集器：单线程的收集器，收集垃圾时，必须 STW，使用复制算法。
  
   * ParNew 收集器：Serial 收集器的多线程版本，也需要 STW，使用复制算法。
  
   * Parallel Scavenge 收集器：类似 ParNew 收集器，但核心目标是达到一个可控的吞吐量。假设虚拟机总共运行 100 分钟，其中垃圾回收花掉 1 分钟，那么吞吐量就是 99%。

   * Serial Old 收集器：是 Serial 收集器的老年代版本，单线程的收集器，使用标记-整理算法。

   * Parallel Old 收集器：是 Parallel Scavenge 收集器的老年代版本，多线程的收集器，使用标记-整理算法。

   * CMS 收集器：是一种以获得最短回收停顿时间为目标的收集器，使用标记-清除算法，执行过程：初始标记（ 仅标记一下 GC-Roots 能**直接关联**到的对象），并发标记（ 执行 GC-Roots Tracing 的过程 ），重新标记（ 为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录 ），并发清除（ 回收所有的垃圾对象 ）。第 1、3 两个阶段依然会引发 STW，而第 2、4 两个阶段可以和应用程序并发执行，但当收集结束后会产生大量空间碎片。可以通过配置 -XX:+UseCMSCompactAtFullCollection 参数强制 JVM 在 Full GC 完成后对老年代进行压缩，执行一次空间碎片整理，在这过程中同样也会引发 STW。为了减少 STW 发生的次数，还可以配置 -XX:+CMSFullGCsBeforeCompaction=n 参数，在执行了 n 次 Full GC 后，JVM 才会对老年代执行空间碎片整理。

   * G1 收集器：G1 收集器将堆空间分割成了若干个相同大小的区域，即 region，包括 Eden、Survivor、Old 和 Humongous 四种类型。其中 Humongous 是特殊的 Old 类型，专门放置大型对象。执行过程：
     
     * 初始标记：触发 Young GC，此时会引发 STW，标记 GC-Roots 直接可达的存活对象（ 复制算法 ）。
  
     * 扫描根区域：并发地扫描 Survivor 区中引用到老年代的引用。
     
     * 并发标记：执行 GC-Roots Tracing 的过程，在整个堆内存中查找存活的对象（ 标记-整理算法 ）。
  
     * 重新标记：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，同样会引发 STW。

     * 清理：根据 Garbage First 原则，选择一部分内存块进行回收。

CMS 收集器和 G1 收集器的区别：
   
   * CMS 收集器作用于老年代，需要配合新生代的 Serial 或 ParNew 收集器一起使用；G1 收集器的收集范围是新生代和老年代，不需要结合其他收集器使用；
   
   * CMS 收集器使用的是**标记-清除**算法进行垃圾回收，容易产生内存碎片；G1 收集器使用的是**标记-整理**算法，清理完成后会进行空间整合，减少了内存的空间碎片。
   
   * CMS 收集器每次都会回收整个 Eden + Old 的内存, 而回收内存所需要的时间就取决于内存的大小以及实际垃圾的多少，所以垃圾回收时间是不可控的；而 G1 每次并不会回收整代内存，到底回收多少内存取决于用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。

## 对象实例化的过程

**1. 确认类元信息是否存在**

当虚拟机接收到 new 指令时，首先会在元数据区中检查是否包含目标类元信息。如果不存在，那么在双亲委派模式下，使用当前的类加载器以 ClassLoader + 包名 + 类名作为 Key 查找对应的 .class 字节码文件。如果没有找到该文件，则抛出 ClassNotFoundException 异常；否则执行类加载流程并在堆内存中生成对应的 Class 对象。
    
**2. 分配对象内存**
    
首先计算对象占用大小，如果对象的成员变量是引用变量，仅需要分配引用变量的空间即可，即 4 个字节。接着在堆内存中划分一块内存给新对象，这个过程是需要进行同步操作的，可以采用 CAS 或者区域加锁等方式保证分配操作的原子性。
    
**3. 设置默认值**

成员变量都需要设置为默认值，即各种形式的零值。
    
**4. 设置对象头**
    
设置新对象的哈希码、GC 信息、锁信息和对象所属的类元信息等。
    
**5. 执行 init() 方法**
    
初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内存中该对象的首地址赋值给虚拟机栈上的引用变量。
