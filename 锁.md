# 锁

## 一、悲观锁和乐观锁

### 为什么会诞生非互斥同步锁 —— 互斥同步锁的劣势

* 阻塞和**唤醒**带来的性能劣势

* **永久**阻塞：如果持有锁的线程被永久阻塞了，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行。

* **线程优先级反转**

### 什么是悲观锁和乐观锁

* 悲观锁：如果我不锁住这个资源，当别人来争抢时，就会造成数据结果的错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容的万无一失。Java 中悲观锁的实现就是 **synchronized** 和 **Lock** 相关类。

* 乐观锁：认为自己在处理操作的时候不会有其它线程来干扰，所以并**不会锁住**被操作的对象。在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果**没被改变过**，就说明真的是只有我自己在操作，那我就正常去修改数据。如果数据和我**一开始拿到的不一样了**，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略。Java 中乐观锁的实现一般都是利用 **CAS** 算法来实现的，例如 **Atomic 原子类**、**并发容器**等。

### 典型例子

* Git（ 乐观锁 ）

* 数据库

    * select for update（ 悲观锁 ）

    * 用 version 控制数据库（ 乐观锁 ）

### 开销对比

* 悲观锁的原始开销要于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。

* 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。

### 悲观锁和乐观锁的适用场景

* 悲观锁：适合**并发写入多**的场景，适用于临界区**持锁时间比较长**的情况，悲观锁可以避免大量的无用自旋消耗，典型情况：
    
    1. 临界区有 **IO** 操作

    2. 临界区**代码复杂**或者循环量大

    3. 临界区**竞争非常激烈**

* 乐观锁：适合**并发写入少、大部分是读取**的场景，不加锁能让读取性能大幅提高。
