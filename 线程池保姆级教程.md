# 线程池

---

## Executors

### 1. newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

#### 为什么不推荐使用`FixedThreadPool`？

FixedThreadPool 使用无界队列 LinkedBlockingQueue 且队列容量为 Integer.MAX_VALUE，作为线程池的工作队列会对线程池带来如下影响：

1. 当线程池中的线程数达到 `corePoolSize` 后，新提交的任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；
2. 由于使用无界队列使`maximumPoolSize` 将是一个无效参数，因为不可能存在任务队列满的情况。所以通过创建 FixedThreadPool 的源码可以看到创建的 FixedThreadPool 参数 `corePoolSize` 和 `maximumPoolSize` 是被设置为同一个值。
3. 由于 1 和 2，使用无界队列时 `keepAliveTime` 将是一个无效参数；
4. 运行中的 FixedThreadPool 在不执行 shutdown() 或 shutdownNow() 方法的情况下不无法拒绝任务的，因此在任务比较多的时候会导致 OutOfMemeoryError 异常。

### 2. newSingleThreadPool

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

SingleThreadExecutor 作为 FixedThreadPool 的孪生兄弟，其参数 `corePoolSize` 和 `maximumPoolSize` 都被设置为 1，其他参数和 FixedThreadPool 相同。

### 3. newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

CachedThreadPool 的参数`corePoolSize` 的初始值被设置为 0，而 `maximumPoolSize` 被设置为 Integer.MAX.VALUE，这就使它具备了高度的伸缩性。这也就意味着如果主线程提交任务的速度高于 `corePoolSize`  中线程处理任务的速度时，CachedThreadPool 就会不断地创建出新的线程来助力核心线程。在极端情况下，同样会导致耗尽 CPU 和内存资源。

### 4. newScheduledThreadPool

---

## 1. execute

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 只有当线程池的运行状态为 RUNNING 时，才允许将待执行的任务存入 workQueue 中
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果代码执行这里，说明上面两个判断条件有一个返回了 false，包括两种情况：
    // 1. isRunning(c) == false，说明线程池的运行状态只要不是 RUNNING，就会被立刻判死刑去执行拒绝策略；
    // 2. isRunning(c) == true && workQueue.offer(command) == false，说明 corePoolSize 和 workQueue 都已满载，传入 false 就是为了去检查一下当前正在执行的线程数是否超过 maximumPoolSize，如果没有就去创建工作线程
    else if (!addWorker(command, false))
        reject(command);
}
```



## 2. addWorker

```java
/**
  * 添加新的工作线程到线程池
  * @param firstTask 用户的 runnable，当为 null 时，意味着不再接受新任务，转而需要从 workQueue 中去获取任务
  * @param 方法参数 core 为 true 时表示使用的是线程池的 corePoolSize，为 false 时使用的则是 maximumPoolSize。
  * @return 添加成功就返回 true 否则返回 false
  */
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 如果第一个判断条件不满足，说明线程池的运行状态是 RUNNING，后续的判断条件直接跳过直接返回 false；
        // 第二个判断条件可以这么理解，当线程池的运行状态是 SHUTDOWN 时，说明它不能再接收新的任务，但可以继续执行工作队列中剩余的任务。对应到代码中，三个子条件中任意一个不成立的话都无法满足 SHUTDOWN 状态的性质，返回 false。
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            // 获取线程池中线程的数量
            int wc = workerCountOf(c);
            // 如果线程的数量超过了线程池能承载的最大值就不允许再增加新的线程了；
            // 如果方法参数为 true 时，判断线程的数量是否超过了 corePoolSize，否则判断是否超过了 maximumPoolSize。
            // 外层的 execute() 方法是在满足了当前线程的数量小于 corePoolSize 这个条件后才走进 addWorker() 方法，之所以会在这里再判断一次，个人认为是当两个线程同时满足 if (workerCountOf(c) < corePoolSize) 后，其中一个线程会先于另一个线程执行完 addWorker() 方法。当另一个线程再次拿到 CPU 的时间分片后，如果不再次判断当前线程的数量是否小于 corePoolSize 的话，任其继续执行就会导致正在执行的线程数超过 corePoolSize 的限制。
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS 操作将正在执行的线程数加 1。如果 CAS 失败，重新走遍 for(;;) 再给自己一次机会
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get(); 
            // 再次检查线程池的状态是否和刚进入方法时的一致，不一致的话再次从 retry 标签处进入
            if (runStateOf(c) != rs)
                continue retry;
        }
    }

    // 标记工作线程是否启动成功
    boolean workerStarted = false;
    // 标记工作线程是否创建成功
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建工作线程 Worker，他包含两个成员变量：firstTask 和 thread。firstTask 就是用户传递进来的 runnable，thread 是由用户创建线程池时指定的 ThreadFactory 来创建的（ 强烈建议用户自定义该参数，默认的 ThreadFactory 无法根据业务需求区分线程名 ，当线程数一多就很容易混乱 ）
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
           	// 在执行敏感操作时，都需要只有 mainLock，避免在增加和启动工作线程时被干扰
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
			   // 获取线程池的运行状态
                int rs = runStateOf(ctl.get());

              	// 当线程池的运行状态为 RUNNING 或 SHUTDOWN 且 firstTask 为 null 时允许继续执行
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    // 统计工作线程集合中正在执行任务的工作线程数量
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 工作线程创建成功
                    workerAdded = true;
                }
            } finally {
                // 释放锁
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动工作线程
                t.start();
                // 工作线程启动成功
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            // 如果工作线程启动失败了，不仅要把它从 workers 这个集合中踢出，还要对 workerCount 减 1，这个过程同样需要持有 mainLock（ 但凡涉及对 workers 的操作都需要持有 mainLock ）
            addWorkerFailed(w);
    }
    return workerStarted;
}
```



## 3. runWorker

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

