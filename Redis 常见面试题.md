# Redis 常见面试题

## 1. Redis 数据结构

入门：字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。

高级：HyperLogLog、Geo、Pub/Sub。

## 2. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量 key 的过期时间设置得过于集中，到过期的那个时间点时 Redis 可能会出现短暂的卡顿现象，严重的话会出现缓存雪崩。一般需要在时间上加一个随机值，使得过期时间分散一些。

## 3. Redis 分布式锁

方案 1：使用 `SETNX key value` 指令来争抢锁，只有当 key 不存在的情况下，才将 key 设置为 value，否则不做任何操作。抢到锁之后，再使用 `EXPIRE key seconds` 指令给锁加一个过期时间防止锁忘记释放。

由于 SETNX 和 EXPIRE 并不是原子指令，所以在一起执行会出现问题。也许你会想到使用 Redis 事务来解决，但在这里不行，因为 EXPIRE 命令依赖于 SETNX 的执行结果，而事务中没有 if-else 的分支逻辑，如果 SETNX 没有抢到锁，EXPIRE 就不应该执行。

方案 2：使用 `SET key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]` 指令。

## 4. 假如 Redis 里面有 1 亿个 key，其中有 10W 个 key 是以某个固定的已知前缀开头的，如何将它们全部找出来？ 

* 阻塞式：`KEYS pattern`，由于 Redis 是单线程的，执行该指令时会导致线程阻塞一段时间，直到指令执行完毕，服务才能恢复。

* 非阻塞式：`SCAN cursor [MATCH pattern] [COUNT count]`，返回的结果集有可能重复，因此需要客户端手动去重。

## 5. Redis 如何实现延时队列？

使用 SortedSet，生产者用时间戳加延迟时间作为 score，消息内容作为 member ，然后调用 `ZADD` 指令来生产消息。消费者用 `ZRANGEBYSCORE` 指令获取有序集合的第一个元素，判断当前时间是否已经超过元素对应的 score，如果满足条件就将其从集合中删除，否则继续等待。

## Redis 主从同步

第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

## Redis 两种持久化机制的优缺点

### RDB

优点：RDB 对 Redis 的性能影响非常小，是因为在同步数据的时候它只是 fork 出了一个子进程去做持久化的，而且在数据恢复的时候速度比 AOF 来得快。同时它会生成多个数据文件，每个数据文件分别都代表了某一时刻 Redis 里存储的数据，适合做冷备。

缺点：RDB 都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF 则最多丢一秒的数据，数据完整性上高下立判。

### AOF

优点：RDB 每隔五分钟一次生成快照，但是 AOF 是一秒一次去通过一个后台的线程 fsync 操作，那最多丢这一秒的数据。AOF 在对日志文件进行操作的时候是以 append-only 的方式去写的，是以追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能很强。同时 AOF 日志的可读性也很强，适合做灾难性数据误删除的紧急恢复。

缺点：一样的数据，AOF 文件比 RDB 还要大。
