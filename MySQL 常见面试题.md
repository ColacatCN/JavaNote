# MySQL 常见面试题

## 为什么 InnoDB 表必须包含主键，并且推荐使用整型的自增主键？

如果在建表时没有指定某一列作为主键，那么 MySQL 会扫描整表的所有列，直到找到某一列中的数据都不重复，就将该列作为主键索引来维护整表的数据。如果所有列的数据都存在重复的情况，那么 MySQL 会在后台维护一个**隐藏列**来确保唯一性，这样会降低 MySQL 的执行效率。

使用 B+ 树进行索引查找的过程涉及多次**比大小**，字符串比大小的效率要远远低于整型比大小。同时整型数据即使是使用 BIGINT 类型也才占用 8 个字节，而 UUID 最少也要占用几十个字节，浪费 MySQL 的存储空间。之所以使用自增主键，是因为每次调用 INSERT 插入数据时，新插入的数据都会被插在整个棵树最右边的叶子节点中，可以减少平衡 B+ 树的次数。

## 为什么非主键索引的叶子节点存储的是主键值？

## 索引

### B-Tree 索引和 Hash 索引的区别

1. Hash 索引只包含哈希值和行指针，而不存储列值，所以不能使用索引中的值来避免读取行数据（ 覆盖索引 ）。

2. Hash 索引的数据并不是按照索引主键值的顺序存储的，所以也就无法用于排序。

3. Hash 索引也不支持部分索引列的匹配查找，因为 Hash 索引始终是使用索引列的全部内容来计算哈希值的（ 最左前缀原则 ）。

4. Hash 索引只支持等值比较查询，包括 =、IN()、<=>。也不支持任何范围查询，例如 WHERE age > 10。

5. 如果哈希冲突严重的话，维护索引的操作代价会很大，例如当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用。冲突越严重，对应的链表也就越长，代价也就越大。

### 最左前缀原则

在 MySQL 建立联合索引时会遵守最左前缀匹配原则，联合索引 index_col1_col2_col3 实际建立了（ col1 ）、（ col1，col2 ）、（ col1，col2，col3 ） 三个索引，同时索引列的顺序意味着索引首先按照最左列 col1 进行排序，其次是在 col1 确定的情况下再进行 col2 的排序，col2 是相对于 col1 有序的。

### InnoDB 聚簇索引

InnoDB 聚簇索引的叶子节点存储行数据，因此 InnoDB 必须要有且只有一个聚集索引（ **一级主键** ）。

1. 如果表定义了主键 `Primary Key`，那么主键就是聚簇索引；

2. 如果表没有定义主键，则第一个设置了 `NOT NULL UNIQUE` 的列就是聚簇索引；

3. 否则 InnoDB 会另外创建一个隐藏的 `rowId` 作为聚簇索引。

### InnoDB 非聚簇索引

以主键以外的字段作为**二级主键**构建的 B+ 索引树，称之为非聚簇索引。

### 聚簇索引和非聚簇索引的区别

聚簇索引和非聚簇索引的区别在于，非聚簇索引的叶子节点不存储表中的行数据，而是存储该行所对应的一级主键，想要查找行数据还需要根据一级主键再去聚集索引中进行查找，这个再根据聚集索引查找行数据的过程称为回表。

### 覆盖索引

覆盖索引就是在一个联合索引中包含（ 或者说覆盖 ）了所有需要查询的字段。简而言之，当 SQL 语句中所查询的字段 `SELECT` 和查询条件的字段 `WHERE` 包含在一个联合索引中，这样就可以直接使用二级主键查询出的结果，而不再需要回表到一级主键索引进行二次查询。

这种方式不仅可以避免对一级主键索引的二次查询，也可以减少 I/O 操作的次数。因为索引占用的内存空间要比数据更小，所以可以一次性从磁盘载入更多节点到内存中，提升 SQL 语句的查询性能。

### 索引下推

如果没有索引下推优化，当进行索引查询时，首先根据索引来查找记录，然后再根据 where 条件来过滤记录；在支持索引下推后，MySQL 会在取出索引的同时，判断是否可以进行 where 条件过滤，也就是说提前执行 where 的部分过滤操作。在某些场景下，可以大大减少回表的次数，从而提升整体性能。
