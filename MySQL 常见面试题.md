# MySQL 常见面试题

## 为什么 InnoDB 表必须包含主键，并且推荐使用整型的自增主键？

如果在建表时没有指定某一列作为主键，那么 MySQL 会扫描整表的所有列，直到找到某一列中的数据都不重复，就将该列作为主键索引来维护整表的数据。如果所有列的数据都存在重复的情况，那么 MySQL 会在后台维护一个**隐藏列**来确保唯一性，这样会降低 MySQL 的执行效率。

使用主键索引查找数据时会涉及多次**比大小**的过程，字符串比大小的效率要远远低于整型数据。同时整型数据即使是使用 BIGINT 类型也才占用 8 个字节，而 UUID 最少也要占用几十个字节，增加了使用索引的开销。之所以使用自增主键，是因为每次调用 INSERT 语句插入数据时，新插入的数据都会被插在整棵 B+ 树最右边的叶子节点中，可以减少 B+ 树的平衡次数。

## 索引

### B-Tree 索引和 Hash 索引的区别

1. Hash 索引只包含哈希值和指向行记录的指针，不存储索引的值，也就不能像辅助索引一样使用索引的值来避免读取行记录（ 覆盖索引 ）。

2. Hash 索引不像 B-Tree 索引中的主键索引或辅助索引可以按照主键的值或联合索引首个字段的值进行排序。

3. Hash 索引不支持联合索引中部分字段的匹配查找，因为 Hash 索引始终使用联合索引中所有字段来计算最终的哈希值。

4. Hash 索引只支持等值比较查询，不支持任何形式的范围查询。

5. 如果哈希冲突严重的话，维护索引的操作代价会很大，例如当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用。冲突越严重，对应的链表也就越长，代价也就越大。

### 最佳左前缀原则

在 MySQL 建立联合索引时会遵守最佳左前缀匹配原则，即联合索引中字段的顺序意味着会首先按照最左边的字段 col1 构建出辅助索引的整棵 B+ 树，其次在 col1 确定的情况下再进行字段 col2 的排序，col2 是相对于 col1 有序的，以此类推。实际上联合索引 index_col1_col2_col3 建立了一个单列索引（ col1 ）和两个组合索引（ col1，col2 ）、（ col1，col2，col3 ） 。

### InnoDB 聚簇索引

InnoDB 聚簇索引的叶子节点存储行数据，因此 InnoDB 必须要有且只有一个聚簇索引。

1. 如果表定义了主键 `Primary Key`，那么主键就是聚簇索引；

2. 如果表没有定义主键，则第一个设置了 `NOT NULL UNIQUE` 的字段就是聚簇索引；

3. 否则 InnoDB 会另外创建一个隐藏的 `DB_ROW_ID` 字段作为聚簇索引。

### InnoDB 非聚簇索引（ 辅助索引 ）

以主键以外的字段作为二级主键构建出辅助索引 B+ 树，称之为非聚簇索引。

### 聚簇索引和非聚簇索引的区别

聚簇索引和非聚簇索引的区别在于，非聚簇索引的叶子节点不存储表中的行记录，而是存储该行所对应的主键，想要查找行记录还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找行记录的过程称为**回表**。

### 覆盖索引

`覆盖索引`就是在一个联合索引中包含（ 或者说覆盖 ）了所有需要查询的字段。简而言之，当 SQL 语句中所查询的字段 `SELECT` 和查询条件的字段 `WHERE` 包含在一个联合索引中，这样就可以直接使用辅助索引查询出的结果，而不再需要回表到主键索引进行二次查询。

这种方式不仅可以避免对主键索引的二次查询，也可以减少 I/O 操作的次数。因为索引占用的内存空间要比行记录更小，所以可以一次性从磁盘载入更多节点到内存中，提升 SQL 语句的查询性能。

### MRR

`Multi-Range Read` 优化可适用于 range、ref 和 eq_ref 类型的查询。MRR 优化有以下几个好处：

* MRR 使数据的访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，先对得到的主键进行排序，然后再在主键索引中进行查找。

* 减少缓冲池中页被替换的次数。

* 批量处理对键值的查询操作。

### ICP

> mysql > SELECT * FROM student WHERE name LIKE 'L%' AND age > 30 AND gender = 'F';

根据前面说的“最佳左前缀原则”，该语句在遍历辅助索引时，只会匹配到名字首字母是“L”的记录，接下来是怎么处理的呢？当然就是从第一个首字母是“L”的记录开始，逐个取出对应的主键执行回表操作，到主键索引上找出相应的行数据，再比对 age 和 gender 这两个字段的值是否满足条件。

当 MySQL 5.6 引入`索引下推`后，当联合索引中的部分字段参与范围查询时，这些字段会被下推到存储引擎 `Storage Engine` 层提前进行条件判断，过滤出满足条件的主键后再回表到主键索引上查询对应的行记录。而不是等行记录返回到 `MySQL Server` 层后再去为这些数据进行 `WHERE` 条件的过滤。 

### 索引失效

1. 不遵守最佳左前缀原则

2. 范围查询右边索引失效原理
 
首先字段 A 在 B+ 树上是有序的，所以可以通过二分查找定位到 1，然后将所有大于 1 的主键取出来，此时字段 A 是使用了索引。字段 B 有序的前提是字段 A 是确定的值，那么现在字段 A 是一个大于 1 的范围，满足条件的值可能有 10 个，也可能有 100 个。因此在字段 A 的值大于 1 的那部分 B+ 树中，字段 B 是无序的，所以字段 B 无法使用二分查找进行查询，因此字段 B 也就无法使用索引。

3. `LIKE` 失效原理

* % 号放在右边：由于 B+ 树的索引顺序是按照首字母的大小进行排序的，前缀匹配又是匹配的首字母，所以可以在 B+ 树上进行有序的查找，查找首字母符合要求的数据。

* % 号放在左边：用于匹配字符串末尾的数据，由于尾部的字母是没有顺序的，所以不能按照索引顺序查询，也就用不到索引。

* % 号放在两边：类似于 % 号放在左边，同样无法使用索引。

### EXPALIN 两个核心字段

1. `type`

  * ALL：全表扫描
  
  * index：这个跟全表扫描一样，只是 MySQL 扫描表时是按照索引次序进行的而不是粗暴地直接扫描全表。优点是避免了排序，缺点是要承担按照索引次序读取整个表的开销。
  
  * range：范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配该值的行数据，例如带有 BETWEEN 或在 WHERE 子句中带有 > 的查询。
  
  * ref：同样是索引扫描，它返回所有匹配某个**单值**的行数据，只适用于使用非唯一索引（ 普通索引 ）。
  
  * eq_ref：同样是索引扫描，它**最多**返回**一条**符合条件的行数据，只适用于使用主键索引或唯一索引。
  
 2. `Extra`
 
  * Using index：表示直接通过**辅助索引**就能够获取到所需要的数据，不需要回表；
  
  * Using where：使用 `WHERE` 语句来处理返回的结果集，查询的字段未被索引覆盖。或在查过的过程中没有使用索引。
  
  * Using filesort：表示 MySQL 服务层需要对存储引擎返回的结果集进行外部排序，不能通过索引顺序达到排序的效果。
  
  * Using index condition：表示通过**索引下推**提前过滤了一部分数据，减少了回表的次数。
  
## 你自己使用mysql中遇到过乱码问题没有，如何解决的，产生原因是什么？

1. 在项目工程中检查数据库连接的配置参数中是否指定了编码格式 `characterEncoding=UTF-8`；

2. 通过命令 `show variables like 'char%';` 检查 MySQL 数据库的 `字符集` 格式是 `utf8`。如果不是的话，就在 my.ini 配置文件中分别为 `client` 和 `mysqld` 设置 `default-character-set=utf8` 和 `character-set-server=utf8`。

## 如何在旧表的基础上创建新的主键？

1. 如果旧主键是包含 `AUTO_INCREAMENT` 参数，则需要先删除该配置；

> mysql > ALTER TABLE student MODIFY COLUMN `uuid` BIGINT NOT NULL;

2. 删除旧主键

> mysql > ALTER TABLE student DROP PRIMARY KEY;

> mysql > ALTER TABLE student DROP COLUMN `uuid`;

3. 新增主键

> mysql > ALTER TABLE student ADD COLUMN `id` INT NOT NULL AUTO_INCREAMENT PRIMARY KEY FIRST;
