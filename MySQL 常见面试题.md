# MySQL 常见面试题

## 为什么 InnoDB 表必须包含主键，并且推荐使用整型的自增主键？

如果在建表时没有指定某一列作为主键，那么 MySQL 会扫描整表的所有列，直到找到某一列中的数据都不重复，就将该列作为主键索引来维护整表的数据。如果所有列的数据都存在重复的情况，那么 MySQL 会在后台维护一个**隐藏列**来确保唯一性，这样会降低 MySQL 的执行效率。

使用 B+ 树进行索引查找的过程涉及多次**比大小**，字符串比大小的效率要远远低于整型比大小。同时整型数据即使是使用 BIGINT 类型也才占用 8 个字节，而 UUID 最少也要占用几十个字节，浪费 MySQL 的存储空间。之所以使用自增主键，是因为每次调用 INSERT 插入数据时，新插入的数据都会被插在整个棵树最右边的叶子节点中，可以减少平衡 B+ 树的次数。

## 索引

### B-Tree 索引和 Hash 索引的区别

1. Hash 索引只包含哈希值和行指针，而不存储列值，所以不能使用索引中的值来避免读取行数据（ 覆盖索引 ）。

2. Hash 索引的数据并不是按照索引主键值的顺序存储的，所以也就无法用于排序。

3. Hash 索引也不支持部分索引列的匹配查找，因为 Hash 索引始终是使用索引列的全部内容来计算哈希值的（ 最左前缀原则 ）。

4. Hash 索引只支持等值比较查询，包括 =、IN()、<=>。也不支持任何范围查询，例如 WHERE age > 10。

5. 如果哈希冲突严重的话，维护索引的操作代价会很大，例如当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用。冲突越严重，对应的链表也就越长，代价也就越大。

### 最佳左前缀原则

在 MySQL 建立联合索引时会遵守最佳左前缀匹配原则，即联合索引中字段的顺序意味着首先会按照最左边的字段 col1 构建整棵 B+ 树，其次在 col1 确定的情况下再进行字段 col2 的排序，col2 是相对于 col1 有序的。实际上联合索引 index_col1_col2_col3 建立了一个单列索引（ col1 ）和两个组合索引（ col1，col2 ）、（ col1，col2，col3 ） 。

### InnoDB 聚簇索引

InnoDB 聚簇索引的叶子节点存储行数据，因此 InnoDB 必须要有且只有一个聚簇索引。

1. 如果表定义了主键 `Primary Key`，那么主键就是聚簇索引；

2. 如果表没有定义主键，则第一个设置了 `NOT NULL UNIQUE` 的字段就是聚簇索引；

3. 否则 InnoDB 会另外创建一个隐藏的 `DB_ROW_ID` 字段作为聚簇索引。

### InnoDB 非聚簇索引（ 辅助索引 ）

以主键以外的字段作为二级主键构建的辅助索引树，称之为非聚簇索引。

### 聚簇索引和非聚簇索引的区别

聚簇索引和非聚簇索引的区别在于，非聚簇索引的叶子节点不存储表中的行数据，而是存储该行所对应的主键，想要查找行数据还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找行数据的过程称为回表。

### 覆盖索引

`覆盖索引`就是在一个联合索引中包含（ 或者说覆盖 ）了所有需要查询的字段。简而言之，当 SQL 语句中所查询的字段 `SELECT` 和查询条件的字段 `WHERE` 包含在一个联合索引中，这样就可以直接使用辅助索引查询出的结果，而不再需要回表到主键索引进行二次查询。

这种方式不仅可以避免对主键索引的二次查询，也可以减少 I/O 操作的次数。因为索引占用的内存空间要比数据更小，所以可以一次性从磁盘载入更多节点到内存中，提升 SQL 语句的查询性能。

### 索引下推

> mysql > SELECT * FROM student WHERE name LIKE 'L%' AND age > 30 AND gender = 'F';

根据前面说的“最左前缀原则”，该语句在遍历辅助索引时，只会匹配到名字首字母是“L”的记录，接下来是怎么处理的呢？当然就是从第一个首字母是“L”的记录开始，逐个取出对应的主键执行回表操作，到主键索引上找出相应的行数据，再比对 age 和 gender 这两个字段的值是否满足条件。

当 MySQL 5.6 引入`索引下推`后，当联合索引中的部分字段参与范围查询时，这些字段会被下推到存储引擎 `Storage Engine` 层提前进行条件判断，过滤出满足条件的主键后再回表到主键索引上查询对应的行数据。而不是等行数据返回到服务 `Server` 层后再去为这些数据进行 `WHERE` 条件的过滤。 

### 索引失效

1. 不遵守最佳左前缀原则

2. 范围查询右边索引失效原理
 
首先字段 A 在 B+ 树上是有序的，所以可以通过二分查找定位到 1，然后将所有大于 1 的主键取出来，此时字段 A 是使用了索引。字段 B 有序的前提是字段 A 是确定的值，那么现在字段 A 是一个大于 1 的范围，满足条件的值可能有 10 个，也可能有 100 个。因此在字段 A 的值大于 1 的那部分 B+ 树中，字段 B 是无序的，所以字段 B 无法使用二分查找进行查询，因此字段 B 也就无法使用索引。

3. `LIKE` 失效原理

* % 号放在右边：由于 B+ 树的索引顺序是按照首字母的大小进行排序的，前缀匹配又是匹配的首字母，所以可以在 B+ 树上进行有序的查找，查找首字母符合要求的数据。

* % 号放在左边：用于匹配字符串末尾的数据，由于尾部的字母是没有顺序的，所以不能按照索引顺序查询，也就用不到索引。

* % 号放在两边：类似于 % 号放在左边，同样无法使用索引。

### EXPALIN 两个核心字段

1. `type`

  * ALL：全表扫描
  
  * index：这个跟全表扫描一样，只是 MySQL 扫描表时是按照索引次序进行的而不是粗暴地直接扫描全表。优点是避免了排序，缺点是要承担按照索引次序读取整个表的开销。
  
  * range：范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配该值的行数据，例如带有 BETWEEN 或在 WHERE 子句中带有 > 的查询。
  
  * ref：同样是索引扫描，它返回所有匹配某个**单值**的行数据，只适用于使用非唯一索引（ 普通索引 ）。
  
  * eq_ref：同样是索引扫描，它**最多**返回**一条**符合条件的行数据，只适用于使用主键索引或唯一索引。
  
 2. `Extra`
 
  * Using index：表示直接通过**辅助索引**就能够获取到所需要的数据，不需要回表；
  
  * Using where：使用 `WHERE` 语句来处理返回的结果集，查询的字段未被索引覆盖。或在查过的过程中没有使用索引。
  
  * Using filesort：表示 MySQL 服务层需要对存储引擎返回的结果集进行外部排序，不能通过索引顺序达到排序的效果。
  
  * Using index condition：表示通过**索引下推**提前过滤了一部分数据，减少了回表的次数。
  
## 你自己使用mysql中遇到过乱码问题没有，如何解决的，产生原因是什么？

1. 在项目工程中检查数据库连接的配置参数中是否指定了编码格式 `characterEncoding=UTF-8`；

2. 通过命令 `show variables like 'char%';` 检查 MySQL 数据库的 `字符集` 格式是 `utf8`。如果不是的话，就在 my.ini 配置文件中分别为 `client` 和 `mysqld` 设置 `default-character-set=utf8` 和 `character-set-server=utf8`。

## 如何在旧表的基础上创建新的主键？

1. 删除旧主键的 `AUTO_INCREATMENT` 参数；

> mysql > ALTER TABLE student MODIFY COLUMN `uuid` BIGINT NOT NULL;

2. 删除旧主键

> mysql > ALTER TABLE student DROP PRIMARY KEY;

> mysql > ALTER TABLE student DROP COLUMN `uuid`;

3. 新增主键

> mysql > ALTER TABLE student ADD COLUMN `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY FIRST;
