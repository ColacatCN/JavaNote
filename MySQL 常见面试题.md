# MySQL 常见面试题

## 为什么 InnoDB 表必须包含主键，并且推荐使用整型的自增主键？

如果在建表时没有指定某一列作为主键，那么 MySQL 会扫描整表的所有列，直到找到某一列中的数据都不重复，就将该列作为主键索引来维护整表的数据。如果所有列的数据都存在重复的情况，那么 MySQL 会在后台维护一个**隐藏列**来确保唯一性，这样会降低 MySQL 的执行效率。

使用主键索引查找数据时会涉及多次**比大小**的过程，字符串比大小的效率要远远低于整型数据。同时整型数据即使是使用 BIGINT 类型也才占用 8 个字节，而 UUID 最少也要占用几十个字节，增加了使用索引的开销。之所以使用自增主键，是因为每次调用 INSERT 语句插入数据时，新插入的数据都会被插在整棵 B+ 树最右边的叶子节点中，可以减少 B+ 树的平衡次数。

## 索引

### B-Tree 索引和 Hash 索引的区别

1. Hash 索引只包含哈希值和指向行记录的指针，不存储索引的值，也就不能像辅助索引一样使用索引的值来避免读取行记录（ 覆盖索引 ）。

2. Hash 索引不像 B-Tree 索引中的主键索引或辅助索引可以按照主键的值或联合索引首个字段的值进行排序。

3. Hash 索引不支持联合索引中部分字段的匹配查找，因为 Hash 索引始终使用联合索引中所有字段来计算最终的哈希值。

4. Hash 索引只支持等值比较查询，不支持任何形式的范围查询。

5. 如果哈希冲突严重的话，维护索引的操作代价会很大，例如当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用。冲突越严重，对应的链表也就越长，代价也就越大。

### 最佳左前缀原则

在 MySQL 建立联合索引时会遵守最佳左前缀匹配原则，即联合索引中字段的顺序意味着会首先按照最左边的字段 col1 构建出辅助索引的整棵 B+ 树，其次在 col1 确定的情况下再进行字段 col2 的排序，col2 是相对于 col1 有序的，以此类推。实际上联合索引 index_col1_col2_col3 建立了一个单列索引（ col1 ）和两个组合索引（ col1，col2 ）、（ col1，col2，col3 ） 。

### InnoDB 聚簇索引

InnoDB 聚簇索引的叶子节点存储行数据，因此 InnoDB 必须要有且只有一个聚簇索引。

1. 如果表定义了主键 `Primary Key`，那么主键就是聚簇索引；

2. 如果表没有定义主键，则第一个设置了 `NOT NULL UNIQUE` 的字段就是聚簇索引；

3. 否则 InnoDB 会另外创建一个隐藏的 `DB_ROW_ID` 字段作为聚簇索引。

### InnoDB 非聚簇索引（ 辅助索引 ）

以主键以外的字段作为二级主键构建出辅助索引 B+ 树，称之为非聚簇索引。

### 聚簇索引和非聚簇索引的区别

聚簇索引和非聚簇索引的区别在于，非聚簇索引的叶子节点不存储表中的行记录，而是存储该行所对应的主键，想要查找行记录还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找行记录的过程称为**回表**。

### 覆盖索引

`覆盖索引`就是在一个联合索引中包含（ 或者说覆盖 ）了所有需要查询的字段。简而言之，当 SQL 语句中所查询的字段 `SELECT` 和查询条件的字段 `WHERE` 包含在一个联合索引中，这样就可以直接使用辅助索引查询出的结果，而不再需要回表到主键索引进行二次查询。

这种方式不仅可以避免对主键索引的二次查询，也可以减少 I/O 操作的次数。因为索引占用的内存空间要比行记录更小，所以可以一次性从磁盘载入更多节点到内存中，提升 SQL 语句的查询性能。

### MRR

`Multi-Range Read` 优化可适用于 range、ref 和 eq_ref 类型的查询。MRR 优化有以下几个好处：

* MRR 使数据的访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，先对得到的主键进行排序，然后再在主键索引中进行查找。

* 减少缓冲池中页被替换的次数。

* 批量处理对键值的查询操作。

### ICP

> mysql > SELECT * FROM student WHERE name LIKE 'L%' AND age > 30 AND gender = 'F';

根据前面说的“最佳左前缀原则”，该语句在遍历辅助索引时，只会匹配到名字首字母是“L”的记录，接下来是怎么处理的呢？当然就是从第一个首字母是“L”的记录开始，逐个取出对应的主键执行回表操作，到主键索引上找出相应的行数据，再比对 age 和 gender 这两个字段的值是否满足条件。

当 MySQL 5.6 引入`索引下推`后，当联合索引中的部分字段参与范围查询时，这些字段会被下推到存储引擎 `Storage Engine` 层提前进行条件判断，过滤出满足条件的主键后再回表到主键索引上查询对应的行记录。而不是等行记录返回到 `MySQL Server` 层后再去为这些数据进行 `WHERE` 条件的过滤。 

### 索引失效

1. 不遵守最佳左前缀原则

2. 范围查询右边索引失效原理
 
首先字段 A 在 B+ 树上是有序的，所以可以通过二分查找定位到 1，然后将所有大于 1 的主键取出来，此时字段 A 是使用了索引。字段 B 有序的前提是字段 A 是确定的值，那么现在字段 A 是一个大于 1 的范围，满足条件的值可能有 10 个，也可能有 100 个。因此在字段 A 的值大于 1 的那部分 B+ 树中，字段 B 是无序的，所以字段 B 无法使用二分查找进行查询，因此字段 B 也就无法使用索引。

3. `LIKE` 失效原理

* % 号放在右边：由于 B+ 树的索引顺序是按照首字母的大小进行排序的，前缀匹配又是匹配的首字母，所以可以在 B+ 树上进行有序的查找，查找首字母符合要求的数据。

* % 号放在左边：用于匹配字符串末尾的数据，由于尾部的字母是没有顺序的，所以不能按照索引顺序查询，也就用不到索引。

* % 号放在两边：类似于 % 号放在左边，同样无法使用索引。

### EXPALIN 两个核心字段

1. `type`

  * ALL：全表扫描
  
  * index：这个跟全表扫描一样，只是 MySQL 扫描表时是按照索引次序进行的而不是粗暴地直接扫描全表。优点是避免了排序，缺点是要承担按照索引次序读取整个表的开销。
  
  * range：范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配该值的行数据，例如带有 BETWEEN 或在 WHERE 子句中带有 > 的查询。
  
  * ref：同样是索引扫描，它返回所有匹配某个**单值**的行数据，只适用于使用非唯一索引（ 普通索引 ）。
  
  * eq_ref：同样是索引扫描，它**最多**返回**一条**符合条件的行数据，只适用于使用主键索引或唯一索引。
  
 2. `Extra`
 
  * Using index：表示直接通过**辅助索引**就能够获取到所需要的数据，不需要回表；
  
  * Using where：使用 `WHERE` 语句来处理返回的结果集，查询的字段未被索引覆盖。或在查过的过程中没有使用索引。
  
  * Using filesort：表示 MySQL 服务层需要对存储引擎返回的结果集进行外部排序，不能通过索引顺序达到排序的效果。
  
  * Using index condition：表示通过**索引下推**提前过滤了一部分数据，减少了回表的次数。
  
## 你自己使用mysql中遇到过乱码问题没有，如何解决的，产生原因是什么？

1. 在项目工程中检查数据库连接的配置参数中是否指定了编码格式 `characterEncoding=UTF-8`；

2. 通过命令 `show variables like 'char%';` 检查 MySQL 数据库的 `字符集` 格式是 `utf8`。如果不是的话，就在 my.ini 配置文件中分别为 `client` 和 `mysqld` 设置 `default-character-set=utf8` 和 `character-set-server=utf8`。

## 如何在旧表的基础上创建新的主键？

1. 如果旧主键是包含 `AUTO_INCREAMENT` 参数，则需要先删除该配置；

> mysql > ALTER TABLE student MODIFY COLUMN `uuid` BIGINT NOT NULL;

2. 删除旧主键

> mysql > ALTER TABLE student DROP PRIMARY KEY;

> mysql > ALTER TABLE student DROP COLUMN `uuid`;

3. 新增主键

> mysql > ALTER TABLE student ADD COLUMN `id` INT NOT NULL AUTO_INCREAMENT PRIMARY KEY FIRST;

## MySQL 中 MyISAM 和 InnoDb 两个存储引擎有什么区别？

### MyISAM

* 不支持事务，但每次查询都是原子性的；

* 只支持表级锁，即每次操作都会对整表加锁；

* 存储表的总行数；

* 一张 MyISAM 表由三个文件组成：索引文件、数据文件、表结构文件；

* 采用非聚簇索引，索引的数据域存储着指向数据文件的指针。

### InnoDb

* 支持 ACID 特性的事务，支持事务的四种隔离级别；

* 同时支持表级锁和行级锁；

* 不存储表的总行数；

* 一张 InnoDb 表默认存储在共享表空间内，表的大小不受到操作系统控制，一张表可能分布在多个文件里；

* 主键索引采用聚簇索引，主键索引的数据域存储着行记录；辅助索引的数据域存储着主键值。

## MySQL 中表锁和行锁的含义及区别？

### 加锁方式

显式加锁：`LOCK IN SHARE MODE` 命令会加上共享锁，`FOR UPDATE` 命令会加上排他锁。

隐式加锁：MyISAM 在执行 SELECT 语句时会自动给涉及的表加共享锁，在执行 UPDATE、DELETE 和 INSERT 语句时会自动给涉及的表加排他锁，这个过程并不需要用户干预。

### 表锁

不会出现死锁的情况，但发生锁冲突的几率较高，并发性能低。

### 行锁

会出现死锁的情况，但发生锁冲突的几率较低，并发性能高。

行锁的 3 种算法：

* Record Lock：单个行记录上的锁

* Gap Lock：间隙锁，锁定一个范围，但不包括行记录本身

* Next-key Lock：Record Lock + Gap Lock，锁定一个范围，并且锁定行记录本身

## MySQL 建索引需要遵循哪些原则呢？

1. 必须建立主键索引

2. 为经常需要排序、分组和联合操作的字段建立索引

3. 为经常作为查询条件的字段建立索引（ 覆盖索引 ）

4. 尽量选择区分度高的字段作为索引（ 参考 Cardinality 统计信息 ）

5. 限制索引的数目

6. 尽量使用数据量少的索引（ 摒弃 UUID ）

7. 删除不再使用或者很少使用的索引

8. 尽量使用联合索引，不要新建索引

9. 遵循最佳左前缀原则

## MySQL 一致性非锁定读

### 版本链

在 InnoDb 存储引擎中主键索引的数据域存储着行记录，每条行记录的末尾都包含两个隐藏的字段：`DB_TRX_ID` 和 `DB_ROLL_PTR`。

* `DB_TRX_ID`：当修改某条行记录时，都会把相应的事务 id 赋值给 trx_id 字段。

* `DB_ROLL_PTR`：当读取某条行记录时，可以通过这个指针找到该条行记录在读取前的修改信息。

### ReadView

隔离级别 READ UNCOMMITTED 在读取行记录时不做任何保护，SERIALIZABLE 在读写行记录时通过表锁实现串行化处理。而 READ COMMITTED 和 REPEATABLE READ 则需要借助版本链和 ReadView 来实现一致性非锁定读，核心问题是如何判断版本链中哪个版本的快照对于当前事务是可见的？ReadView 中有四个比较重要的概念：

* `m_ids`：表示在生成 ReadView 时，当前系统中活跃的事务 id 列表。

* `min_trx_id`：表示在生成 ReadView 时，当前系统中活跃的事务 id 列表里最小的事务 id。

* `max_trx_id`：表示在生成 ReadView 时，当前系统中应该分配给下一个事务的 id。

* `creator_trx_id`：表示生成 ReadView 的事务 id。

#### 生成 ReadView 的时机

READ COMMITTED 是在事务执行的过程，每调用一次 SELECT 语句就会生成一个 ReadView；而 REPEATABLE READ 只在事务执行前生成一个 ReadView，后续的查询操作都会复用该 ReadView。

#### 如何通过 ReadView 判断行记录的某个版本是否对当前事务可见？

1. 如果版本链中第一个被访问版本的 `DB_TRX_ID` 与 ReadView 中的 `creator_trx_id` 相同，说明当前事务正在访问自己修改过的行记录，允许其访问；

2. 如果版本链中第一个被访问版本的 `DB_TRX_ID` 小于 ReadView 中的 `min_trx_id`，说明当前事务在生成 ReadView 之前修改该条行记录的事务就已经提交了，同样允许其访问。

3. 如果版本链中第一个被访问版本的 `DB_TRX_ID` 大于 ReadView 中的 `max_trx_id`，说明当前事务在生成 ReadView 之后还有其他事务在修改该条行记录，不允许其访问。此时需要遍历版本链中上一条 `update undo log`，继续根据它的 `DB_TRX_ID` 判断可见性。

4. 如果版本链中第一个被访问版本的 `DB_TRX_ID` 介于 ReadView 中的 `min_trx_id` 和 `max_trx_id` 之间，就需要判断 `DB_TRX_ID` 是不是在 `m_ids` 列表中？

   4.1 如果在：说明当前事务在生成 ReadView 时生成该版本的事务还是活跃的，不允许其访问。此时需要遍历版本链中上一条 `update undo log`，继续根据它的 `DB_TRX_ID` 判断可见性。
 
   4.2 如果不在：说明当前事务在生成 ReadView 时生成该版本的事务已经提交，允许其访问。


