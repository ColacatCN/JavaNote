# 锁

## 一、悲观锁和乐观锁

### 为什么会诞生非互斥同步锁 —— 互斥同步锁的劣势

* 阻塞和**唤醒**带来的性能劣势

* **永久**阻塞：如果持有锁的线程被永久阻塞了，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行。

* **线程优先级反转**

### 什么是悲观锁和乐观锁

* 悲观锁：如果我不锁住这个资源，当别人来争抢时，就会造成数据结果的错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容的万无一失。Java 中悲观锁的实现就是 **synchronized** 和 **Lock** 相关类。

* 乐观锁：认为自己在处理操作的时候不会有其它线程来干扰，所以并**不会锁住**被操作的对象。在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果**没被改变过**，就说明真的是只有我自己在操作，那我就正常去修改数据。如果数据和我**一开始拿到的不一样了**，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略。Java 中乐观锁的实现一般都是利用 **CAS** 算法来实现的，例如 **Atomic 原子类**、**并发容器**等。

### 典型例子

* Git（ 乐观锁 ）

* 数据库

    * select for update（ 悲观锁 ）

    * 用 version 控制数据库（ 乐观锁 ）

### 开销对比

* 悲观锁的原始开销要于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。

* 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。

### 悲观锁和乐观锁的适用场景

* 悲观锁：适合**并发写入多**的场景，适用于临界区**持锁时间比较长**的情况，悲观锁可以避免大量的无用自旋消耗，典型情况：
    
    1. 临界区有 **IO** 操作

    2. 临界区**代码复杂**或者循环量大

    3. 临界区**竞争非常激烈**

* 乐观锁：适合**并发写入少、大部分是读取**的场景，不加锁能让读取性能大幅提高。

## 二、可重入锁

### 什么是可重入

* 摇号的故事

* 具体解释：同一个线程可以多次获取同一把锁，包括 ReentrantLock、synchronized。

### 好处

* 避免死锁

* 提高封装性

### 常用方法

* isHeldByCurrentThread：可以看出锁是否被当前线程所持有

* getQueueLength：可以返回当前正在等待这把锁的队列有多长

## 三、公平锁和非公平锁

### 什么是公平和非公平

公平指的是，按照线程请求的顺序来分配锁；非公平锁指的是，不完全按照线程请求的顺序，在“合适的时机”允许线程插队，而不是盲目插队。

### 为什么要有非公平锁

* 提高执行效率

* 避免唤醒线程带来的空档期

### 公平的情况（ 以 ReentrantLock 为例 ）

### 非公平的情况（ 以 ReentrantLock 为例 ）

### 特例

### 对比公平锁和非公平锁的优缺点

## 共享锁和排他锁

### 什么是共享锁和排他锁

* 共享锁：又称为读锁，获取**共享锁**之后，可以查看但**无法修改和删除数据**，其他线程此时也可以获取该共享锁，同样的它们也无法修改和删除数据。

* 排他锁：又称为独占锁、独享锁

### 读写锁的作用

在没有读写锁之前，假设使用 ReentrantLock，那么虽然可以保证线程安全，但是也浪费了一定的资源（ **当多个读操作同时进行时，并没有线程安全问题** ）。

在读的地方使用读锁，在写的地方使用写锁，灵活控制。如果**没有写锁的情况下，读是无阻塞的**，提高了程序的执行效率。

### 读写锁的规则

* 多个线程只申请读锁，都可以申请到。

* 如果有一个线程已经占了读锁，此时其他线程如果想要申请写锁，则申请写锁的线程会一直等待释放读锁。

* 如果有一个线程已经占了写锁，此时其他线程如果想要申请读锁，则申请写锁的线程会一直等待释放写锁。

* 一句话总结：**要么**是一个或**多**个线程同时有**读**锁，**要么**是**一**个线程有**写**锁，但是**两者不会同时出现**。